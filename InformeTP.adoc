= Base de Datos: Trabajo Práctico 1
Martin Sosa <@gmail.com>; Maxi Schmidt <@gmail.com>; Martin Zavalla <martin.zav99@gmail.com>
v1, {docdate}. Docentes Hernán Czemerinski y Hernán Rondelli (COM-01)
:title-page:
:numbered:
:source-highlighter: coderay
:tabsize: 4


== Introducción

En este trabajo se realizará una base de datos en postgreSQL mediante Go, 
donde se representa un modelo de datos que se usa para almacenar
informacion relativa a clientes de tarjetas de credito, donde se destacan los detalles
de compra, total de gastos, infomación del comercio y el producto, rechazos
o alertas e incluso, información sobre la propia tarjeta y su propietario.

El objetivo del programa es que reconozca y actúa ante situaciones tales como 
autorización de compra, generar resumenes o alertar a los clientes de posibles
problemas. Para ello, se deberá previamente crear una base de datos respetando 
las propiedades de cada tabla , e instanciar datos competentes.

Además, como usuario tendrá la posibilidad de crear la base de datos manualmente
y ver el paso a paso de su proceso o la opcion de que se realice todo automanicamente.
Una de estas es borrar todas las identifiaciones primareas y foraneas (PK's y FK's) que
solo se puede realizar mediente la opcion manual.
 

== Descripción

El programa inicia mostrando un menú princpipal de bienvenida (CLI) para un manejo
más ordenado con la base de datos. Donde se podra elegir entre crearla y cargarla
con toda la informacion necesaria automaticamente o hacerlo manualmente. Tambien
se le agrega una tercer opcion que es para realizar pruebas de funcionamiento.
Por ultimo , se encuentra la opcion de salir.


*Modelo de menu principal*

		[ 1 ] Crear Base tpgossz (Auto)
		[ 2 ] Crear Base tpgossz (Manual)
		[ 3 ] Remover PKs y FKs
		[ 4 ] Realizar consumos de prueba
		[ 5 ] Guardar datos (BoltDB)

		[ 0 ] Salir

		
La primera opción es la encargada de crear la base de datos completa 
con tablas, PK's, FK's, clientes,negocios y funciones de forma automatica. 

*Entre las funciones se encuentran:*

*Autorizacion de compra:* donde se verifica la existencia de una tarjeta 
mediante su número y código de seguridad, el estado de vigencia y su límite
de compra. Así, se puede validar la compra o generar un rechazo para luego
cargar la información en su respectiva tabla dependiendo del resultado.

*Generar resumen:* en la cual se devuelve la información detallada de un cliente
y el total de gastos junto a infomación sobre todas sus compras realizadas en
un periodo específico.

*Generar alertas:* que posee una lógica para generar alertas por fraudes.
Esta debe ejecutarse cada cierto tiempo de forma automática, donde las
alertas a detectar se basan en la compra de productos en diferentes comercios
dentro de un rango de tiempo dependiendo de si sucede en locales de igual o
distinto código postal. Luego, se guardan los datos en su respectiva tabla con
un código identificador para saber que tipo de alerta se produjo.

La segunda opción muestra un menu secundario con las opciones para realizar 
las mismas acciones que la opción 1, pero con la posibilidad de eliminar la 
base de datos creada, crearla manualmente, conectarse, crear las tablas requeridas 
para el funcionamiento, agregar los PK's y FK's, completar la base de datos con 
información (popular la base de datos), agregar funciones, y por último, 
salir o desconectarse.

En la tercera opción podemos eliminar los PK's y FK's de todas las tablas existentes
para visualizar posibles inconvenientes al no poseer y prescindir de las mismas.

En la cuarta opción se crea una tabla con consumos virtuales para probar el sistema, 
la misma contiene los atributos: nrotarjeta, codseguridad, nrocomercio, monto. Y se realiza
un procedimiento de testeo, que pida autorización para todos los consumos virtuales.

En la quinta opción, y por último, para poder comparar el modelo relacional con un modelo no 
relacional NoSQL, se guardan los datos de clientes, tarjetas, comercios, y compras (tres por 
cada entidad y de forma hardcodeada) en una base de datos NoSQL basada en JSON. Para ello, 
utilizamos la base de datos BoltDB.

*Modelo de menu secundario*

		[ 1 ] Eliminar Base tpgossz
		[ 2 ] Crear Base tpgossz
		[ 3 ] Conectar con Base tpgossz
		[ 4 ] Crear tablas
		[ 5 ] Agregar PKs y FKs
		[ 6 ] Popular Base de datos
		[ 7 ] Agregar Stored Procedures y Triggers

		[ 0 ] Volver
		
Cada vez que el usuario elija una opción la función se ejecutará y hará un seguimiento
con impresiones por pantalla para indicar su estado y correcto funcionamiento. 

En caso de no elegir la opción de salida válida, se mostrará un mensaje
"No elegiste ninguno" y se volverá al menu para seleccionar la siguiente tarea.
    

=== Dificultades y Procedimientos

_Inicio y Planificación del Proyecto_

Para empezar a modelar la base de datos decidimos utilizar el programa *lucidchart*
debido a que nos permitio de forma mas comoda organizar y ordenar las relaciones
entre las entidades. 

.diagrama_base 
image::diagrama_base.jpg[]



_Creando Tablas, PK's y FK's_

Para agregar las Pk's y Fk's se utilizo el formato dado en clases (ver en implementacion).
En este caso, se realizo una funcion para agregar las pks y fks en sus respectivas
tablas y otra para borrarlas. Resaltamos que, debido al diagrama realizado previamente, 
fue mucho más fácil visualizar de forma rápida y precisa las identificaciones y sus relaciones.

_Instancia de Datos_

Al momento de ingresar información sobre los comercios y clientes a la base 
de datos, en lugar de inventar y escribir manualmente, se obtuvo la
información de paginas de internet con datos públicos y verdaderos.
Donde algunos fueron modificados a conveniencia, para usarlo a modo de prueba en
las proximas funciones a realizar. En el caso de los números de tarjetas de crédito y 
los CVV, se utilizó un programa online que genera los mismo de forma aleatoria, con el
fin de que la base de datos parezca mucho más realista: *https://herramientas-online.com/generador-tarjeta-credito-cvv.php* 

_Implementación de "codmotivo" en la Tabla Rechazos_

Al momento de generar los rechazos encontramos mayor comodidad al implementar en 
la tabla Rechazo un *codmotivo*, que funciona de forma semejante al codalerta de la tabla Alerta,
en este caso a través de cinco variables numéricas se puende constatar el motivo del rechazo.

*MOTIVOS:*

- Tarjeta no valida o no vigente = 0
- Codigo de seguridad invalido = 1
- Plazo de vigencia expirado = 2
- La tarjeta se encuentra suspendida = 3
- Supera limite de tarjeta = 4

== Implementación

En esta sección se incluye el código fuente correctamente formateado y
comentado, si corresponde.

Además, por cada fragmento de código
relevante—i.e. función, método, procedimiento—se debe dar una
breve descripción, decir qué hace, y especificar los parámetros que
toma la función/método/procedimiento, junto con los valores que devuelve
ó modifica.

_No debería incluirse el código de librerías/frameworks que se
utilicen—a no ser que sea absolutamente necesario._

== Conclusiones

Una vez realizado el proyecto aprendimos el correcto manejo de SQL en Go, el uso de Postgres y la 
administración de una base de datos relacionada con tarjetas de creditos con una simulación realista. 
La comprensión de los temas incluidos en el trabajo práctico nos hicieron cambiar drásticamente nuestra 
visión sobre los mismos, porque hasta el momento de iniciarlo, solo habías indagado en peticiones 
simples con tablas pequeñas o poco relacionadas entre sí. 

Al ir avanzando en nuestro trabajo confirmamos nuestras sospechas con respecto a los resultados obtenidos, 
logrando un programa sólido con CLI (en inglés, command-line interface) que cumpliera con todo lo 
requerido en el enunciado inicial, propuesto por los docentes a cargo.

En el caso de que tuvieramos que repetir el proyecto realizariamos pequeños cambios como: poder tener comandos 
dentro del CLI que permitiecen al usuario ingresar clientes, negocios, consumos, etc. También es verdad que esta 
herramientas de trabajo es nueva para todos los integrantes, fue un poco intrincado el inicio del proyecto, pero
una vez afianzado lo más básico del trabajo práctico (la conexión con el servidos, la creación de la base de datos 
con sus tablas respectivas y sus PK's y FK's), lo demás dluyo con mayor facilidad para nosotros.

Una vez observado el resultado del proyecto nos quedamos con ganas de implementar nuevas base de datos de mayor
complejidad o con diferentes particularidades, también de hacer modificaciones sustanciales al código presentado 
para mayor cantidad de funcionalidades para nuestro programa que creamos o para aumentar la escalabilidad del proyecto.
